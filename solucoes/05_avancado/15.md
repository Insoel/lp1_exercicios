## Problema

15 - Considera a seguinte classe:

```cs
public class Weapon
{
    public float AttackPower { get; }
    public float Durability { get; }

    public Weapon(float attackPower, float durability)
    {
        AttackPower = attackPower;
        Durability = durability;
    }
}
```

Assume que temos uma lista de armas, ou seja, uma variável do tipo
`List<Weapon>` e responde às seguintes questões:

1. Faz as alterações necessárias à classe `Weapon` de modo a que quando
invocarmos o método
[`Sort`](https://docs.microsoft.com/pt-pt/dotnet/api/system.collections.generic.list-1.sort)
(ou mais concretamente, o seu
[_overload_ sem parâmetros](https://docs.microsoft.com/pt-pt/dotnet/api/system.collections.generic.list-1.sort#System_Collections_Generic_List_1_Sort)) da classe `List<T>`, as instâncias de `Weapon` fiquem ordenadas por
`AttackPower` decrescente. _Sugestão:_ a classe `Weapon` tem de implementar
[`IComparable<T>`](https://docs.microsoft.com/pt-pt/dotnet/api/system.icomparable-1).
2. Cria uma classe `Program` com um método `Main()` para testar uma lista de
várias instâncias de `Weapon`, nomeadamente a sua ordenação por `AttackPower`
decrescente usando o método
[`Sort()`](https://docs.microsoft.com/pt-pt/dotnet/api/system.collections.generic.list-1.sort#System_Collections_Generic_List_1_Sort)
sem parâmetros.
3. O método
[`Sort`](https://docs.microsoft.com/pt-pt/dotnet/api/system.collections.generic.list-1.sort)
da classe `List<T>` tem vários _overloads_. Um deles,
[`Sort(IComparer<T>)`](https://docs.microsoft.com/pt-pt/dotnet/api/system.collections.generic.list-1.sort#System_Collections_Generic_List_1_Sort_System_Collections_Generic_IComparer__0__),
permite ordenar a lista usando o critério de ordenação definido numa classe
extra. Tal classe, como indicado na assinatura do método, tem de implementar a
interface
[`IComparer<T>`](https://docs.microsoft.com/pt-pt/dotnet/api/system.collections.generic.icomparer-1).
Cria uma classe deste tipo cujo critério de ordenação seja `Durability`
crescente.  
4. Adiciona ao método `Main()` da classe `Program` um teste à ordenação
por `Durability` crescente usando o método
[`Sort(IComparer<T>)`](https://docs.microsoft.com/pt-pt/dotnet/api/system.collections.generic.list-1.sort#System_Collections_Generic_List_1_Sort_System_Collections_Generic_IComparer__0__)
e a classe desenvolvida no ponto anterior.


## Soluções

### Solução 1

1. ```
	public class Weapon : IComparable<Weapon>
    {
        public float AttackPower { get; }
        public float Durability { get; }

        public int CompareTo(Weapon other)
        {
            // If other is not a valid object reference, this instance is greater.
            if (other == null) return 1;

            // The temperature comparison depends on the comparison of 
            // the underlying Double values. 
            return AttackPower.CompareTo(other.AttackPower);
        }

        public Weapon(float attackPower, float durability)
        {
            AttackPower = attackPower;
            Durability = durability;
        }
    }
	```
	
	
2. ```
	public class Program
    {
        static void Main(string[] args)
        {
            Random random = new Random();
            Weapon[] weapons = new Weapon[4];
            for (int i = 0; i < weapons.Length; i++)
            {
                weapons[i] = new Weapon(random.Next(0, 10), random.Next(0, 10));
            }


            List<Weapon> wpnList = new List<Weapon>();
            wpnList.AddRange(weapons);
            wpnList.Sort();
            foreach (Weapon weapon in wpnList)
                Console.Write(weapon.AttackPower + "\n");
        }
    }
	```
	
3.  ```
	public class WeaponComparer : IComparer<Weapon>
    {
        public int Compare(Weapon x, Weapon y)
        {
            if (x.Durability == y.Durability)
            {
                return 0;
            }
            else
            {
                return x.Durability.CompareTo(y.Durability);
            }
        }
    }
	```
	
4.  Ainda por ser feita!

*Solução 1 por Ianis Arquissandas*
